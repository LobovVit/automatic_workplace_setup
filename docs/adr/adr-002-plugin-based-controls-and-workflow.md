# ADR-002: Плагинная архитектура контролей и движок Workflow в мастере

- **Статус:** принят
- **Дата:** 2025-11-25

## Контекст

Мастеру автонастройки нужно:
- выполнять десятки проверок: браузер, CryptoPro, плагин, сертификаты, драйвер токена, конкурирующие клиенты, доступность портала и т.д.;
- уметь добавлять новые проверки без переписывания существующей логики;
- показывать пользователю общий прогресс и итоговый статус по всем пунктам.

При этом:
- перечень контролей со временем будет меняться (новые требования, новые версии ПО);
- логика последовательного выполнения шагов одинакова для всех контролей.

## Решение

Принята архитектура с:
1. **Движком Workflow (WorkflowEngine)**, который:
   - хранит список контролей (`IControl`);
   - последовательно вызывает `check()` и, при необходимости, `fix()` для каждого контрола;
   - агрегирует результаты и передаёт их в UI и логгер.

2. **Плагинными контролями (Controls)**, каждый из которых реализует интерфейс `IControl`:

```text
interface IControl {
  getName() : String
  check()   : CheckResult
  fix(result : CheckResult) : FixResult
}
```

Примеры контролей:
- `BrowserGostControl`
- `CryptoProCspControl`
- `CryptoProPluginControl`
- `CertificatesRootIntermediateControl`
- `RutokenDriverControl`
- `PersonalCertificateControl`
- `CompetingClientsControl`
- `PortalAvailabilityControl`

## Аргументы в пользу решения

- **Модульность.** Добавление нового контрола не требует изменений в движке или других контролях — достаточно реализовать `IControl`.
- **Тестируемость.** Каждый контрол можно тестировать в изоляции (unit-тесты).
- **Повторное использование.** Общая логика (логирование, работа с UI, формирование отчёта) сосредоточена в WorkflowEngine и вспомогательных сервисах.
- **Простота визуализации.** WorkflowEngine легко сообщает UI прогресс (номер шага / общее число шагов) и статус каждого контрола.

## Рассмотренные альтернативы

### Вариант A: «Монолитный» сценарий в одном классе

Все проверки и исправления находятся в одном большом классе/методе.

**Минусы:**
- сложность сопровождения и роста;
- высокий риск регрессий при изменениях;
- невозможно переиспользовать части логики.

**Вывод:** отвергнуто из-за плохой масштабируемости и сопровождения.

### Вариант B: Жёстко закодированные шаги без интерфейсов

Контроли — отдельные классы, но без общего интерфейса, вызываются напрямую.

**Минусы:**
- нельзя выстроить единый механизм перебора и отчётности;
- сложнее внедрить новые типы контролей и сценарии (повторные проверки, частичный запуск и т.д.).

**Вывод:** отвергнуто в пользу явного интерфейса и списка контролей.

## Последствия

### Положительные

- Простое расширение функционала мастера: новый контроль = новый класс + регистрация в списке.
- Удобная схема для документирования и C4-диаграмм (отдельный пакет Controls).
- Облегчённая отладка: можно запускать отдельные контролы.

### Отрицательные

- Нужно поддерживать базовую инфраструктуру (интерфейс, базовые типы результатов, WorkflowEngine).
- Возможен небольшой накладной код для регистрации контролей (конфигурация списка). 
