# Архитектура подсистемы автонастройки АРМ для входа в ЛК ГИИС ЭБ

---

# 1. Цели и требования

Подсистема должна обеспечивать:

- диагностику готовности АРМ к работе в ЛК ГИИС «Электронный бюджет»;
- автоматическое исправление основных ошибок;
- отображение новостей и аварийных сообщений;
- предоставление ссылок на скачивание мастеров автонастройки (Windows / Linux);
- предоставление инструкции по ручной настройке;
- отсутствие выделенного backend API (вся логика — внутри CMS Grav);
- отказоустойчивость: **Load Balancer → Nginx → Grav Master/Slave**;
- безопасность — все операции с криптографией выполняются локально мастером;
- отсутствие передачи криптографических данных наружу.

---

# 2. Общая архитектура решения

## 2.1. Основные компоненты

### 2.1.1. Веб-портал на CMS Grav

Функции:

- отображение страницы входа;
- показ новостей;
- показ аварийных сообщений;
- доступ к инструкции;
- предоставление файлов мастеров.

Особенности:

- реализован целиком на CMS Grav;
- без отдельного SPA и backend-сервера.

---

### 2.1.2. Мастер автонастройки Windows

- desktop-приложение;
- Avalonia UI;
- .NET 8;
- C#;
- XAML;
- MVVM.

Решает задачи:

- проверка и установка CryptoPro CSP;
- проверка и установка CryptoPro Plugin;
- установка корневых и промежуточных сертификатов;
- проверка драйверов Рутокен;
- проверка личного сертификата;
- проверка конкурирующих TLS-клиентов;
- проверка доступности ЛК ГИИС «ЭБ».

---

### 2.1.3. Мастер автонастройки Linux

- тот же технологический стек (Avalonia/.NET/C#/XAML/MVVM);
- функции аналогичны Windows-версии с учётом особенностей ОС Linux.

---

### 2.1.4. CMS Grav Master/Slave

**Grav Master**

- единственный узел с включённой админкой;
- доступен только из локальной сети ФК;
- точка управления контентом (новости, аварии, инструкции, файлы мастеров и сертификатов).

**Grav Slave**

- один или несколько read-only узлов;
- обслуживают пользовательские запросы;
- получают контент по синхронизации с Master (rsync, Git, CI/CD, плагины Grav и т. д.).

---

### 2.1.5. Nginx Reverse Proxy

- принимает HTTP(S)-запросы от балансировщика;
- проксирует на Grav Master/Slave;
- отдаёт статику (HTML/JS/CSS, файлы мастеров, PDF, сертификаты);
- ведёт access.log и error.log.

---

### 2.1.6. Load Balancer (MTProto LB)

- балансирует трафик между несколькими Nginx;
- выполняет health-check;
- обеспечивает отказоустойчивость.

---

### 2.1.7. ЛК ГИИС ЭБ

- внешняя по отношению к подсистеме система;
- конечная точка входа пользователя после настройки АРМ.

---

# 3. Архитектура мастера автонастройки

## 3.1. Технологическая платформа

Мастер автонастройки реализован на базе:

- языка C#;
- платформы .NET 8+;
- фреймворка Avalonia UI;
- декларативной разметки XAML;
- архитектурного паттерна MVVM.

Преимущества:

- единый код для Windows и Linux;
- современный кроссплатформенный UI;
- чёткое разделение логики и представления;
- удобное расширение за счёт плагинной модели контролей.

---

## 3.2. Логическая структура мастера

### 3.2.1. UI Layer (Views + XAML)

Включает:

- стартовый экран;
- экран проверки;
- экран исправления;
- итоговый экран;
- окно просмотра/сохранения отчёта.

Разметка реализована в XAML-файлах, связывается с ViewModels через привязки данных.

---

### 3.2.2. ViewModels (MVVM)

Отвечают за:

- состояние экранов;
- команды (Commands);
- взаимодействие с WorkflowEngine;
- обновление UI по результатам работы контролей.

---

### 3.2.3. WorkflowEngine

Оркестратор выполнения контролей. Псевдокод:

    foreach (var control in controls)
    {
        var check = control.Check();
        if (!check.IsOk)
        {
            var fix = control.Fix(check);
            // сохранение информации о фиксе
        }
        // сохранение информации о проверке
    }

Задачи WorkflowEngine:

- выбор и последовательный запуск контролей;
- агрегирование результатов;
- формирование общего статуса;
- передача информации в слой ViewModels.

---

# 4. Controls (Check/Fix)

## 4.1. Интерфейс контролей

    interface IControl
    {
        string Name { get; }
        CheckResult Check();
        FixResult Fix(CheckResult result);
    }

Каждый контроль реализует:

- метод `Check()` — диагностика одного аспекта настройки;
- метод `Fix()` — попытка автоматического исправления проблемы (если возможно).

---

## 4.2. Основные контроли

| Контроль                           | Назначение                                           |
|------------------------------------|------------------------------------------------------|
| BrowserGostControl                 | Проверка ГОСТ-совместимого браузера                  |
| CryptoProCspControl                | Проверка/установка CryptoPro CSP                     |
| CryptoProPluginControl             | Проверка/установка плагина CryptoPro                 |
| CertificatesRootIntermediateControl| Установка корневых и промежуточных сертификатов УЦ   |
| RutokenDriverControl               | Проверка и установка драйвера Рутокен                |
| PersonalCertificateControl         | Проверка наличия и корректности личного сертификата  |
| CompetingClientsControl            | Обнаружение конкурирующих TLS-клиентов              |
| PortalAvailabilityControl          | Проверка доступности ЛК ГИИС «ЭБ»                    |

Контроли могут расширяться (поддержка новых проверок без изменения ядра мастера).

---

## 4.3. Логирование и отчёты

- Для каждого шага Check/Fix формируется запись в журнале.
- Журнал и итоговый отчёт хранятся **локально** на рабочем месте.
- По запросу пользователя отчёт можно сохранить в файл (например, для прикрепления в обращение в поддержку).
- Конфиденциальные криптографические данные в отчёты не попадают.

---

# 5. Архитектура веб-части (CMS Grav + Nginx + Load Balancer)

## 5.1. Отсутствие выделенного frontend/backend

В системе **нет**:

- отдельного SPA-приложения (React, Vue и т. п.);
- отдельного backend-приложения (Java/Go/Python/.NET);
- REST API для портала.

Вся веб-часть реализована средствами **CMS Grav**:

- страницы входа и помощи;
- новости и аварийные сообщения;
- ссылки на файлы мастеров;
- ссылки на инструкции и сертификаты.

---

## 5.2. Ручное обновление контента

Через админку Grav Master администратор:

- редактирует тексты аварийных уведомлений;
- публикует и архивирует новости;
- обновляет файлы мастеров (Win/Linux);
- обновляет инструкции и сертификаты.

Автоматической генерации статусов и новостей нет — это осознанное решение, упрощающее архитектуру и эксплуатацию.

---

## 5.3. Схема Grav Master/Slave

- **Grav Master** — единственный узел, где разрешено редактирование контента (админка); доступен только из локальной сети.
- **Grav Slave** — один или несколько узлов, работающих в режиме read-only и обслуживающих пользовательский трафик.

Синхронизация Master → Slave:

- rsync;
- Git-репозиторий;
- CI/CD-pipeline;
- плагины Grav для репликации.

Конкретная реализация выбирается службой эксплуатации.

---

## 5.4. Reverse Proxy на Nginx

Nginx выполняет:

- приём HTTP/HTTPS от Load Balancer;
- проксирование запросов к Grav Master/Slave;
- раздачу статических файлов (мастера, PDF, сертификаты);
- логирование запросов и ошибок (access.log, error.log).

---

## 5.5. Load Balancer (MTProto или аналог)

Маршрут запроса:

    Пользователь → Load Balancer → Nginx → Grav Slave → Статические файлы/страницы

Функции:

- распределение нагрузки;
- health-check Nginx/Grav;
- возможность масштабирования по горизонтали.

---

## 5.6. Мониторинг и метрики (ELK-стек)

Схема:

    Nginx access.log/error.log
        → Filebeat/Logstash
        → Elasticsearch
        → Kibana (дашборды)

Основные метрики:

- количество скачиваний мастеров;
- коды ответов (2xx/4xx/5xx);
- время ответа;
- доступность портала.

---

# 6. Обоснование архитектуры

## 6.1. Выбор CMS Grav

Плюсы:

- файловая CMS, не требуется отдельная СУБД;
- минимум компонентов и зависимостей;
- удобная админка для не-разработчиков;
- естественная поддержка статических и полу-статических страниц;
- простая кластеризация Master/Slave.

---

## 6.2. Выбор Avalonia UI для мастеров

Плюсы:

- единый код для Windows и Linux;
- современный, отзывчивый UI;
- поддержка XAML и MVVM;
- хорошая интеграция с .NET;
- удобная плагинная модель (Controls).

---

## 7. C4-диаграммы

В проект включены следующие диаграммы уровней C4:

1. **Level 1 — System Context**
    - Расположение: `docs/c4/c4-level1-system-context.puml`
    - Изображение: `docs/images/c4-level1-system-context.png`

2. **Level 2 — Containers (обновлённый вариант с двумя Grav Slave)**
    - Расположение: `docs/c4/c4-level2-containers.puml`
    - Изображение: `docs/images/c4-level2-containers.png`
    - Особенность: топология серверной части отражает два независимых Grav Slave:
      ```
      LB → Nginx1 → GravSlave1
      LB → Nginx2 → GravSlave2
      ```

3. **Level 3 — Components (Master)**
    - Расположение: `docs/c4/c4-level3-master-components.puml`
    - Изображение: `docs/images/c4-level3-master-components.png`

4. **Level 4 — Code Level (WorkflowEngine + Controls)**
    - Расположение: `docs/c4/c4-level4-master-code.puml`
    - Изображение: `docs/images/c4-level4-master-code.png`

5. **Event Flow — последовательность взаимодействий**
    - Расположение: `docs/event-flow/event-flow-master.puml`
    - Изображение: `docs/images/event-flow-master.png`

# 8. Event Flow (последовательность событий)

Высокоуровневый сценарий работы:

1. Пользователь открывает портал помощи/входа.
2. Запрос идёт через Load Balancer → Nginx → Grav Slave.
3. Пользователь видит новости, аварийные сообщения и ссылки.
4. Пользователь скачивает мастер автонастройки (Windows или Linux).
5. Пользователь запускает мастер на своём АРМ.
6. Мастер выполняет цикл Check/Fix по всем контролям.
7. Мастер формирует итоговый отчёт и отображает его.
8. Пользователь по кнопке «Перейти в ЛК» открывает ЛК ГИИС «ЭБ».

Диаграмма последовательностей (PlantUML) располагается в `docs/erd/event-flow-master.puml`.

---

# 9. ADR (Architectural Decision Records)

В проекте ведётся набор ADR, фиксирующих ключевые решения:

- **ADR-001** — форм-фактор мастера (desktop-приложение).
- **ADR-002** — архитектура WorkflowEngine + Controls.
- **ADR-003** — структура отчёта мастера.
- **ADR-004** — отказ от backend и переход к полностью статической архитектуре Grav.
- **ADR-005** — использование CMS Grav в конфигурации Master/Slave без отдельного backend.

---

# 10. Заключение

Предложенная архитектура:

- проста и прозрачна;
- минимизирует количество компонентов;
- обеспечивает отказоустойчивость за счёт LB + Nginx + Grav Slave;
- предоставляет удобный механизм ручного управления контентом через Grav Master;
- даёт мощный и расширяемый инструмент автонастройки АРМ на основе Avalonia UI и .NET;
- соответствует требованиям безопасности и эксплуатации в инфраструктуре ФК.